<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chatter</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar styles for dark mode */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
        }
        .chat-container {
            max-height: 90vh;
        }
        .messages-list {
            flex-grow: 1;
            overflow-y: auto;
            max-height: calc(100vh - 200px); /* Adjust based on header/footer height */
        }
        .messages-list::-webkit-scrollbar {
            width: 8px;
        }
        .messages-list::-webkit-scrollbar-thumb {
            background-color: #374151; /* Dark gray thumb */
            border-radius: 4px;
        }
        .messages-list::-webkit-scrollbar-track {
            background-color: #1f2937; /* Even darker track */
        }
        /* Style for action buttons using SVG icons */
        .room-action-btn:hover svg {
            filter: brightness(1.2);
        }
        
        /* Custom Context Menu Styling */
        .custom-context-menu {
            position: fixed; 
            z-index: 100;
            background-color: #1f2937; /* Dark background */
            border: 1px solid #374151;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            padding: 0.25rem 0;
            min-width: 12rem;
            opacity: 0; 
            transition: opacity 0.1s;
        }
        .custom-context-menu.visible {
            opacity: 1;
        }
        .custom-context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: #d1d5db; /* Light gray text */
            font-size: 0.875rem;
            transition: background-color 0.1s;
        }
        .custom-context-menu-item:hover {
            background-color: #374151; /* Hover background */
        }
        .custom-context-menu-item-destructive {
            color: #f87171; /* Red text for destructive action */
        }
        .custom-context-menu-item-destructive:hover {
            background-color: #b91c1c; 
            color: white;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-100 min-h-screen antialiased">

    <div id="main-app" class="flex flex-col md:flex-row h-screen">

        <!-- Sidebar: User Profile & Rooms -->
        <div class="w-full md:w-80 bg-gray-800 p-4 flex flex-col space-y-6 shadow-2xl overflow-y-auto border-r border-gray-700">
            <h1 class="text-2xl font-bold text-indigo-400">Public Chat Rooms</h1>
            
            <!-- URL INSTRUCTION HEADER -->
            <div class="bg-indigo-900/50 text-indigo-300 p-3 rounded-lg text-sm border border-indigo-700">
                <p class="font-bold mb-1">Room URL Commands:</p>
                <ul class="list-disc ml-4 space-y-0.5">
                    <li>To create a new room. Enter the #room_name on the address will create your own room name.</li>
                    <li>To embedded code or auto join room. Enter the #join=room_name but after you hit the entered need to reload first to see your room will auto joined.</li>
                    <li>The Room list scroll down to see the room list and your own room.</li>
                </ul>
            </div>
            
            <!-- User Profile Section -->
            <div id="user-profile-section" class="bg-gray-700 p-3 rounded-lg shadow-inner">
                <p class="text-sm text-gray-400 mb-2">Logged in as:</p>
                <div id="user-display" class="font-medium text-lg text-white truncate">Loading...</div>
                <div id="user-id-display" class="text-xs text-indigo-300 mb-3 truncate">ID: Loading...</div>

                <form id="set-name-form" class="flex flex-col space-y-2">
                    <input type="text" id="display-name-input" placeholder="Set your unique name" 
                           class="p-2 rounded-lg bg-gray-600 border border-gray-500 text-white placeholder-gray-400 focus:ring-indigo-500 focus:border-indigo-500">
                    <button type="submit" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 rounded-lg transition duration-200">
                        Save Name
                    </button>
                    <p id="name-status" class="text-xs text-red-400 h-4"></p>
                </form>
            </div>

            <!-- Room Creation (HIDDEN, but function remains for implicit URL creation) -->
            <div class="bg-gray-700 p-3 rounded-lg shadow-inner hidden">
                <h2 class="text-lg font-semibold mb-2 text-indigo-300">Create New Room</h2>
                <form id="create-room-form" class="flex flex-col space-y-2">
                    <input type="text" id="new-room-name" placeholder="Enter room name" 
                           class="p-2 rounded-lg bg-gray-600 border border-gray-500 text-white placeholder-gray-400 focus:ring-green-500 focus:border-green-500">
                    <button type="submit" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 rounded-lg transition duration-200">
                        Create Room
                    </button>
                    <p id="room-status" class="text-xs text-red-400 h-4"></p>
                </form>
            </div>
            
            <!-- Room List (Unified and Searchable) -->
            <div class="flex-grow space-y-4">
                <div class="bg-gray-700 p-3 rounded-lg shadow-inner">
                    <input type="text" id="room-search-input" placeholder="Search rooms by name..."
                           class="w-full p-2 rounded-lg bg-gray-600 border border-gray-500 text-white placeholder-gray-400 focus:ring-green-500 focus:border-green-500">
                </div>

                <!-- Unified Room List -->
                <h2 class="text-lg font-semibold text-indigo-300 border-b border-indigo-700 pb-1">All Available Rooms</h2>
                <div id="unified-room-list" class="space-y-2">
                    <div class="text-gray-400 text-sm">Loading rooms...</div>
                </div>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="flex-grow flex flex-col bg-gray-900 border-l border-gray-700">
            <!-- Chat Header -->
            <header class="p-4 bg-gray-800 shadow-lg flex-shrink-0">
                <h2 id="current-room-name" class="text-2xl font-bold text-white">Select a Room</h2>
            </header>

            <!-- Messages Display -->
            <div id="messages-list" class="messages-list p-4 flex flex-col space-y-4">
                <div class="text-center text-gray-500 p-10" id="initial-prompt">
                    Select a room from the left sidebar or use a **#room_name** URL command to start chatting.
                </div>
            </div>

            <!-- Message Input (Footer) -->
            <footer id="chat-footer" class="p-4 bg-gray-800 flex-shrink-0 border-t border-gray-700 hidden">
                <form id="message-form" class="flex items-center space-x-3">
                    <input type="text" id="message-input" placeholder="Type a message..." disabled
                           class="flex-grow p-3 rounded-lg bg-gray-700 border border-gray-600 text-white placeholder-gray-400 focus:ring-indigo-500 focus:border-indigo-500">
                    <button type="submit" id="send-button" disabled
                            class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                        Send
                    </button>
                </form>
            </footer>
        </div>
    </div>

    <script>
        // --- Static Configuration ---
        const DEFAULT_EMBEDDED_ROOM_NAME = "General_Lobby"; 
        const BASE_EMBED_URL = 'https://chattingembedded.unaux.com/'; 
        const API_ENDPOINT = 'https://chattingembedded.unaux.com/api.php'; // Your PHP file endpoint

        // --- Globals ---
        const userId = localStorage.getItem('chat_user_id') || crypto.randomUUID();
        localStorage.setItem('chat_user_id', userId);

        // --- State Variables ---
        let currentUserId = userId;
        let currentUserName = 'Anonymous';
        let currentRoomId = null;
        let currentRoomName = null;
        let currentRoomOwnerId = null; 
        let lastMessageId = 0; 

        // --- DOM Elements ---
        const unifiedRoomListElement = document.getElementById('unified-room-list'); // Unified list
        const roomSearchInput = document.getElementById('room-search-input');
        const messagesListElement = document.getElementById('messages-list');
        const currentRoomNameElement = document.getElementById('current-room-name');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message-input');
        const chatFooter = document.getElementById('chat-footer');
        const initialPrompt = document.getElementById('initial-prompt');
        const userDisplay = document.getElementById('user-display');
        const userIdDisplay = document.getElementById('user-id-display');
        const displayNameInput = document.getElementById('display-name-input');
        const nameStatus = document.getElementById('name-status');
        const sendButton = document.getElementById('send-button');

        // --- Polling Timers ---
        let roomPollingInterval = null;
        let messagePollingInterval = null;

        // --- Utility Functions ---
        function getUrlParam(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }
        
        function getUrlHash() {
            const hash = window.location.hash;
            if (!hash || hash.length <= 1) return null;

            let content = hash.substring(1); 
            
            if (content.startsWith('join=')) {
                return { type: 'explicit_join', name: content.substring(5) }; 
            }
            
            if (!content.includes('=')) {
                return { type: 'implicit_create', name: content };
            }

            return null; 
        }

        function copyToClipboard(text, message) {
            const tempInput = document.createElement('textarea');
            tempInput.value = text;
            document.body.appendChild(tempInput);
            tempInput.select();
            
            try {
                document.execCommand('copy');
                showMessageBox(message, 'info');
            } catch (err) {
                console.error('Copy failed:', err);
                showMessageBox('Failed to copy to clipboard. Please copy manually.', 'error');
            }
            document.body.removeChild(tempInput);
        }

        // --- Core API Functions (Wrapper for Fetch) ---

        async function apiCall(action, method = 'GET', data = null) {
            const url = `${API_ENDPOINT}?action=${action}`;
            const options = {
                method: method,
                headers: { 'Content-Type': 'application/json' },
            };

            if (data && method !== 'GET') {
                options.body = JSON.stringify(data);
            }

            try {
                for (let i = 0; i < 3; i++) {
                    const response = await fetch(url, options);
                    if (response.status !== 429) { 
                        const result = await response.json();
                        
                        if (!result.success) {
                            console.error(`[API Error: ${action}]`, result.error);
                            return { success: false, error: result.error };
                        }
                        return { success: true, data: result.data };
                    }
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                }
                return { success: false, error: 'API calls throttled or failed after retries.' };
            } catch (error) {
                console.error(`[Fetch Error: ${action}]`, error);
                return { success: false, error: 'Network or API connection failed.' };
            }
        }

        // --- Message Box/Modal implementation (replacing alert/confirm/prompt) ---

        function showMessageBox(message, type = 'info', callback = null, initialValue = '') {
            let existingBox = document.getElementById('custom-message-box');
            if (existingBox) existingBox.remove();

            const box = document.createElement('div');
            box.id = 'custom-message-box';
            box.className = 'fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'bg-gray-800 p-6 rounded-xl shadow-2xl w-96 max-w-sm border border-gray-700 space-y-4';

            const p = document.createElement('p');
            p.innerHTML = message; 
            p.className = 'text-white font-medium';
            modalContent.appendChild(p);

            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'flex justify-end space-x-3';
            
            let inputEl = null;
            if (type === 'prompt') {
                inputEl = document.createElement('input');
                inputEl.type = 'text';
                inputEl.value = initialValue;
                inputEl.placeholder = 'New room name';
                inputEl.className = 'w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white placeholder-gray-400 focus:ring-indigo-500 focus:border-indigo-500 mb-4';
                modalContent.insertBefore(inputEl, buttonContainer);
                setTimeout(() => inputEl.focus(), 50);
            }
            
            const closeBox = () => box.remove();

            if (type === 'info' || type === 'error') {
                const okBtn = document.createElement('button');
                okBtn.textContent = 'OK';
                okBtn.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200';
                okBtn.onclick = closeBox;
                buttonContainer.appendChild(okBtn);
            } else if (type === 'confirm' || type === 'prompt') {
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.className = 'text-gray-400 hover:text-white font-semibold py-2 px-4 rounded-lg transition duration-200';
                cancelBtn.onclick = closeBox;
                buttonContainer.appendChild(cancelBtn);

                const confirmBtn = document.createElement('button');
                confirmBtn.textContent = type === 'prompt' ? 'Save' : 'Confirm';
                confirmBtn.className = 'bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200';
                
                confirmBtn.onclick = () => {
                    closeBox();
                    if (callback) {
                        if (type === 'prompt') {
                            callback(inputEl.value);
                        } else {
                            callback();
                        }
                    }
                };
                buttonContainer.appendChild(confirmBtn);
                
                if (inputEl) {
                     inputEl.addEventListener('keyup', (e) => {
                        if (e.key === 'Enter') {
                            confirmBtn.click();
                        }
                    });
                }
            }

            modalContent.appendChild(buttonContainer);
            box.appendChild(modalContent);
            document.body.appendChild(box);
        }

        // --- Profile Management ---

        async function fetchProfile(userId) {
            const result = await apiCall(`profile&user_id=${userId}`);
            if (result.success && result.data) {
                return result.data.display_name;
            }
            return null; 
        }

        async function setProfile(displayName) {
            nameStatus.textContent = 'Saving...';
            const result = await apiCall('profile', 'POST', {
                user_id: currentUserId,
                display_name: displayName
            });

            if (result.success) {
                currentUserName = displayName;
                userDisplay.textContent = currentUserName;
                nameStatus.textContent = 'Name saved!';
                nameStatus.classList.remove('text-red-400');
                nameStatus.classList.add('text-green-400');
            } else {
                nameStatus.textContent = result.error || 'Failed to save name.';
                nameStatus.classList.remove('text-green-400');
                nameStatus.classList.add('text-red-400');
            }
        }

        function renderProfile() {
            userIdDisplay.textContent = `ID: ${currentUserId}`;
            userDisplay.textContent = currentUserName;
            displayNameInput.value = currentUserName === 'Anonymous' ? '' : currentUserName;
        }

        // --- Room Management ---
        let allCachedRooms = []; 
        let isCurrentRoomOwner = false; 

        function startRoomPolling() {
            if (roomPollingInterval) clearInterval(roomPollingInterval);
            fetchRooms(); 
            roomPollingInterval = setInterval(fetchRooms, 5000); 
        }

        async function fetchRooms() {
            const result = await apiCall('rooms');
            if (result.success) {
                allCachedRooms = result.data; 
                renderRooms(allCachedRooms);
            }
        }
        
        function renderRoomItem(room, isOwner, isCurrent) {
            const roomDiv = document.createElement('div');
            
            let baseClasses = "p-3 rounded-lg cursor-pointer transition duration-150 truncate flex items-center justify-between room-list-item"; 
            if (isCurrent) {
                // Highlight color depends on ownership status for the active room
                roomDiv.className = `${baseClasses} ${isOwner ? 'bg-green-600' : 'bg-indigo-600'} text-white font-semibold shadow-xl`;
            } else {
                roomDiv.className = `${baseClasses} bg-gray-700 hover:bg-gray-600 text-gray-200`;
            }

            // Room Name Display container (used flex for badge alignment)
            const nameSpan = document.createElement('span');
            nameSpan.className = "flex-grow truncate flex items-center";
            
            // Add room name text
            nameSpan.innerHTML = room.name;
            
            // Add Owner Badge if the current user owns the room
            if (isOwner) {
                nameSpan.innerHTML += `<span class="ml-2 px-2 py-0.5 text-xs font-medium bg-green-700 text-green-200 rounded-full">Owner</span>`;
            }
            
            // Attach click listener for switching rooms
            nameSpan.addEventListener('click', () => switchRoom(room.id, room.name, room.user_id));
            
            roomDiv.appendChild(nameSpan);

            // Owner Actions (Rename, Delete)
            if (isOwner) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = "flex space-x-2 ml-4 flex-shrink-0";

                // Rename Button 
                const renameBtn = document.createElement('button');
                renameBtn.className = "text-yellow-400 hover:text-yellow-300 p-1 rounded-full hover:bg-gray-800 room-action-btn";
                renameBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zm-4.606 2.606a2 2 0 010 2.828L10.828 12 12 10.828l-.793-.793a1 1 0 00-.001-1.414.999.999 0 00-1.414 0l-4.596 4.596a2 2 0 00-.707 1.414V17h4.086a2 2 0 001.414-.707l4.596-4.596a.999.999 0 000-1.414 1 1 0 00-1.414 0L10.828 8.172l-1.414-1.414z"/></svg>`;
                renameBtn.title = "Rename Room";
                renameBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    promptRenameRoom(room.id, room.name);
                });
                actionsDiv.appendChild(renameBtn);

                // Delete Button 
                const deleteBtn = document.createElement('button');
                deleteBtn.className = "text-red-500 hover:text-red-400 p-1 rounded-full hover:bg-gray-800 room-action-btn";
                deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 10-2 0v6a1 1 0 102 0V8z" clip-rule="evenodd"/></svg>`;
                deleteBtn.title = "Delete Room";
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    confirmDeleteRoom(room.id, room.name);
                });
                actionsDiv.appendChild(deleteBtn);
                
                roomDiv.appendChild(actionsDiv);
            }
            
            // Set data attributes for context menu
            roomDiv.dataset.roomId = room.id;
            roomDiv.dataset.roomName = room.name;
            roomDiv.dataset.roomOwnerId = room.user_id;

            // Right-click listener for context menu
            roomDiv.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showRoomContextMenu(e, room.id, room.name, room.user_id);
            });

            return roomDiv;
        }


        function renderRooms(allRooms) {
            const searchTerm = roomSearchInput.value.toLowerCase().trim();
            
            unifiedRoomListElement.innerHTML = ''; // Clear the unified list

            // Check current room's ownership status during render (CRITICAL FOR AUTH)
            const currentRoomData = allRooms.find(r => r.id == currentRoomId);
            if (currentRoomData) {
                currentRoomOwnerId = currentRoomData.user_id;
                isCurrentRoomOwner = currentRoomOwnerId === currentUserId;
            } else {
                isCurrentRoomOwner = false;
                currentRoomOwnerId = null;
            }

            let renderedCount = 0;

            allRooms.forEach(room => {
                // Filter room based on search term
                if (searchTerm && !room.name.toLowerCase().includes(searchTerm)) {
                    return; 
                }

                const isOwner = room.user_id === currentUserId;
                const isCurrent = room.id == currentRoomId;
                
                // Render the item
                const roomItem = renderRoomItem(room, isOwner, isCurrent);

                unifiedRoomListElement.appendChild(roomItem);
                renderedCount++;
            });

            // Handle empty state messages
            if (renderedCount === 0) {
                const message = searchTerm 
                    ? `<div class="text-gray-400 text-sm p-2">No rooms match your search for "${searchTerm}".</div>`
                    : `<div class="text-gray-400 text-sm p-2">No public rooms found.</div>`;
                unifiedRoomListElement.innerHTML = message;
            }
        }


        async function createRoom(roomName) {
            const result = await apiCall('rooms', 'POST', {
                name: roomName,
                user_id: currentUserId
            });

            if (result.success) {
                return { success: true, id: result.data.id }; 
            } else {
                return { success: false, error: result.error }; 
            }
        }
        
        async function deleteRoom(roomId, roomName) {
            const result = await apiCall(`rooms&room_id=${roomId}`, 'DELETE');
            
            if (result.success) {
                console.log(`Room '${roomName}' deleted.`);
                showMessageBox(`Room "${roomName}" has been successfully deleted.`, 'info');
                
                if (currentRoomId == roomId) {
                    const defaultRoom = allCachedRooms.find(r => r.name === DEFAULT_EMBEDDED_ROOM_NAME);
                    if (defaultRoom) {
                        // Switch to default room if the current room was deleted
                        switchRoom(defaultRoom.id, defaultRoom.name, defaultRoom.user_id);
                    } else {
                        // Clear the chat view if no fallback exists
                        currentRoomId = null; 
                        currentRoomName = null;
                        currentRoomOwnerId = null;
                        isCurrentRoomOwner = false;
                        currentRoomNameElement.textContent = "Select a Room";
                        messagesListElement.innerHTML = '';
                        initialPrompt.classList.remove('hidden');
                        chatFooter.classList.add('hidden');
                    }
                }
                fetchRooms(); 
            } else {
                showMessageBox(`Failed to delete room: ${result.error}`, 'error');
            }
        }

        function confirmDeleteRoom(roomId, roomName) {
            showMessageBox(`Are you sure you want to permanently delete the room: "${roomName}"? This action cannot be undone.`, 'confirm', () => {
                deleteRoom(roomId, roomName);
            });
        }

        async function renameRoom(roomId, oldName, newName) {
            newName = newName.trim();
            if (!newName || newName === oldName) return;

            const result = await apiCall('rename_room', 'POST', {
                room_id: roomId,
                new_name: newName
            });

            if (result.success) {
                console.log(`Room renamed to '${newName}'.`);
                showMessageBox(`Room successfully renamed to "${newName}".`, 'info');
                
                if (currentRoomId == roomId) {
                    currentRoomName = newName;
                    currentRoomNameElement.textContent = newName;
                }
                fetchRooms(); 
            } else {
                showMessageBox(`Failed to rename room: ${result.error}`, 'error');
            }
        }

        function promptRenameRoom(roomId, roomName) {
            showMessageBox(`Enter a new name for the room "${roomName}":`, 'prompt', (newName) => {
                if (newName && newName.trim()) {
                    renameRoom(roomId, roomName, newName.trim());
                }
            }, roomName);
        }

        function switchRoom(roomId, roomName, roomOwnerId) {
            if (roomId === currentRoomId) return; 

            currentRoomId = roomId;
            currentRoomName = roomName;
            currentRoomOwnerId = roomOwnerId;
            isCurrentRoomOwner = currentRoomOwnerId === currentUserId; 
            lastMessageId = 0; 

            currentRoomNameElement.textContent = currentRoomName;
            messagesListElement.innerHTML = ''; 
            chatFooter.classList.remove('hidden');
            initialPrompt.classList.add('hidden');
            messageInput.disabled = false;
            sendButton.disabled = false;
            
            // Re-render rooms to apply the active style and ownership checks
            renderRooms(allCachedRooms);

            if (messagePollingInterval) clearInterval(messagePollingInterval);
            startMessagePolling();
        }


        // --- Message Management (Polling) ---

        function startMessagePolling() {
            messagePollingInterval = setInterval(fetchMessages, 1500); 
            fetchMessages(); 
        }

        async function fetchMessages() {
            if (!currentRoomId) return;

            const result = await apiCall(`messages&room_id=${currentRoomId}&last_id=${lastMessageId}`);

            if (result.success && result.data && result.data.length > 0) {
                renderMessages(result.data);
                lastMessageId = result.data[result.data.length - 1].id; 
            }
        }

        async function sendMessage(messageText) {
            if (!currentRoomId || !messageText.trim()) return;

            messageInput.disabled = true;
            sendButton.disabled = true;

            await apiCall('messages', 'POST', {
                room_id: currentRoomId,
                user_id: currentUserId,
                user_name: currentUserName,
                message_text: messageText
            });

            await fetchMessages(); 
            
            messageInput.value = '';
            messageInput.disabled = false;
            sendButton.disabled = false;
            messageInput.focus();
        }
        
        async function editMessage(messageId, newText) {
             const result = await apiCall('edit_message', 'POST', {
                message_id: messageId,
                new_text: newText,
                user_id: currentUserId 
            });

            if (result.success) {
                showMessageBox('Message edited successfully.', 'info');
                lastMessageId = 0; 
                await fetchMessages(); 
            } else {
                showMessageBox(`Failed to edit message: ${result.error}`, 'error');
            }
        }

        async function deleteMessage(messageId, isOwnerOverride) {
            const result = await apiCall('delete_message', 'POST', {
                message_id: messageId,
                room_id: currentRoomId,
                user_id: currentUserId,
                is_owner_override: isOwnerOverride 
            });

            if (result.success) {
                showMessageBox('Message deleted successfully.', 'info');
                lastMessageId = 0; 
                await fetchMessages(); 
            } else {
                showMessageBox(`Failed to delete message: ${result.error}`, 'error');
            }
        }


        function renderMessages(newMessages) {
            const isScrolledToBottom = messagesListElement.scrollHeight - messagesListElement.clientHeight <= messagesListElement.scrollTop + 1;

            newMessages.forEach(msg => {
                const isMine = msg.user_id === currentUserId;
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `flex ${isMine ? 'justify-end' : 'justify-start'} message-wrapper`;
                messageDiv.dataset.messageId = msg.id;
                messageDiv.dataset.messageUserId = msg.user_id;
                
                messageDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMessageContextMenu(e, msg);
                });


                const bubble = document.createElement('div');
                bubble.className = `max-w-xs lg:max-w-md px-4 py-2 rounded-xl shadow-md ${
                    isMine ? 'bg-indigo-600 text-white rounded-br-none' : 'bg-gray-700 text-gray-100 rounded-tl-none'
                }`;

                const nameSpan = document.createElement('div');
                nameSpan.className = `text-xs font-semibold mb-1 ${isMine ? 'text-indigo-200' : 'text-green-400'}`;
                nameSpan.textContent = isMine ? 'You' : msg.user_name;

                const textP = document.createElement('p');
                textP.className = 'text-sm break-words';
                textP.textContent = msg.message_text;
                textP.id = `msg-text-${msg.id}`; 

                const timeDiv = document.createElement('div');
                timeDiv.className = `text-[10px] mt-1 ${isMine ? 'text-indigo-300 text-right' : 'text-gray-400 text-left'}`;
                timeDiv.textContent = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                bubble.appendChild(nameSpan);
                bubble.appendChild(textP);
                bubble.appendChild(timeDiv);
                messageDiv.appendChild(bubble);
                messagesListElement.appendChild(messageDiv);
            });

            if (isScrolledToBottom || messagesListElement.children.length <= newMessages.length) {
                messagesListElement.scrollTop = messagesListElement.scrollHeight;
            }
        }
        
        // --- Context Menu Implementation ---
        
        function hideContextMenu() {
            const existingMenu = document.getElementById('custom-context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            document.removeEventListener('click', hideContextMenu);
        }

        function createContextMenu(event) {
            hideContextMenu(); 

            const menu = document.createElement('div');
            menu.id = 'custom-context-menu';
            menu.className = 'custom-context-menu';
            menu.style.position = 'fixed'; 
            
            document.body.appendChild(menu);
            
            setTimeout(() => { 
                document.addEventListener('click', hideContextMenu);
            }, 10); 
            
            return menu;
        }
        
        function positionContextMenu(menu, event) {
            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            let x = event.clientX;
            let y = event.clientY;
            const padding = 10; 

            if (x + menuWidth + padding > windowWidth) {
                x = windowWidth - menuWidth - padding;
            }

            if (y + menuHeight + padding > windowHeight) {
                y = windowHeight - menuHeight - padding;
            }
            
            if (x < padding) x = padding;
            if (y < padding) y = padding;

            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            
            menu.classList.add('visible');
        }


        function addContextMenuItem(menu, label, action, isDestructive = false) {
            const item = document.createElement('div');
            item.textContent = label;
            item.className = `custom-context-menu-item ${isDestructive ? 'custom-context-menu-item-destructive' : ''}`;
            item.onclick = (e) => {
                e.stopPropagation();
                hideContextMenu();
                action();
            };
            menu.appendChild(item);
        }

        function showRoomContextMenu(e, roomId, roomName, roomOwnerId) {
            const menu = createContextMenu(e);
            const isOwner = currentUserId === roomOwnerId;
            
            addContextMenuItem(menu, 'Join Room', () => {
                switchRoom(roomId, roomName, roomOwnerId);
            });

            addContextMenuItem(menu, 'Copy Embed Code', () => {
                const embedCode = `${BASE_EMBED_URL}#join=${roomName}`;
                copyToClipboard(embedCode, 'Embed code copied to clipboard! Share the link to invite others.');
            });
            
            if (isOwner) {
                const separator = document.createElement('div');
                separator.className = 'border-t border-gray-600 my-1 mx-2';
                menu.appendChild(separator);

                addContextMenuItem(menu, 'Rename Room', () => {
                    promptRenameRoom(roomId, roomName);
                });

                addContextMenuItem(menu, 'Delete Room', () => {
                    confirmDeleteRoom(roomId, roomName);
                }, true);
            }
            
            positionContextMenu(menu, e);
        }
        
        function showMessageContextMenu(e, msg) {
            const menu = createContextMenu(e);
            const isMine = msg.user_id === currentUserId;
            const isRoomOwner = isCurrentRoomOwner;
            
            const messageId = msg.id;
            const messageText = msg.message_text;

            if (isMine) {
                addContextMenuItem(menu, 'Edit Message', () => {
                    showMessageBox(`Editing Message (ID: ${messageId}):`, 'prompt', (newText) => {
                        if (newText && newText.trim()) {
                            editMessage(messageId, newText.trim());
                        }
                    }, messageText);
                });
            }

            if (isMine || isRoomOwner) {
                const label = isMine ? 'Delete Message' : 'Delete User Message (Owner)';
                const isOwnerOverride = isRoomOwner && !isMine; 

                addContextMenuItem(menu, label, () => {
                    confirmDeleteMessage(messageId, isOwnerOverride);
                }, true); 
            }
            
            positionContextMenu(menu, e);
        }
        
        function confirmDeleteMessage(messageId, isOwnerOverride) {
            const confirmationText = isOwnerOverride 
                ? "As the room owner, are you sure you want to delete this user's message?"
                : "Are you sure you want to delete your message?";
            
            showMessageBox(confirmationText, 'confirm', () => {
                deleteMessage(messageId, isOwnerOverride);
            });
        }
        
        // --- Room Creation/Joining Logic ---

        async function handleRoomJoin(joinAction) {
            const roomName = joinAction.name;
            const actionType = joinAction.type;

            let roomIdToJoin = null;
            let roomOwnerIdToJoin = null;

            // 1. --- Phase 1: Creation Attempt (Implicit/Default Only) ---
            if (actionType === 'implicit_create' || actionType === 'default') {
                const createResult = await createRoom(roomName);
                
                if (createResult.success) {
                    console.log(`Auto-created room via ${actionType}: ${roomName}`);
                    roomIdToJoin = createResult.id;
                    roomOwnerIdToJoin = currentUserId; 
                    await fetchRooms(); 
                } else if (createResult.error.includes("already exists")) {
                    console.log(`Room ${roomName} already exists, fetching latest list before join. (FIX APPLIED)`);
                    // CRITICAL FIX: Ensure fresh room list when creation fails due to existence
                     await fetchRooms(); 
                }
            } else if (actionType === 'explicit_join') {
                // Explicit join requires fetching the list first to check existence
                await fetchRooms(); 
            }
            
            // 2. --- Phase 2: Find Room ID in Cache ---
            if (!roomIdToJoin) {
                const existingRoom = allCachedRooms.find(r => r.name === roomName);
                if (existingRoom) {
                    roomIdToJoin = existingRoom.id;
                    roomOwnerIdToJoin = existingRoom.user_id;
                }
            }

            // 3. --- Phase 3: Error Handling / Fallback ---
            
            if (!roomIdToJoin) {
                if (actionType === 'explicit_join') {
                    showMessageBox(`Error: The room **'${roomName}'** does not exist. A room joined via the **'#join='** command must be created first.`, 'error');
                } else {
                     console.error(`Attempted creation of ${roomName} failed, or room not found in list after fetch. Falling back to default.`);
                }
                
                const defaultRoom = allCachedRooms.find(r => r.name === DEFAULT_EMBEDDED_ROOM_NAME);
                if (defaultRoom) {
                    switchRoom(defaultRoom.id, defaultRoom.name, defaultRoom.user_id);
                } else {
                    startRoomPolling();
                    return; 
                }
            }
            
            if (roomIdToJoin) {
                switchRoom(roomIdToJoin, roomName, roomOwnerIdToJoin);
            }

            startRoomPolling();
        }


        // --- Event Listeners and Initialization ---
        
        window.addEventListener('scroll', hideContextMenu);
        window.addEventListener('resize', hideContextMenu);
        document.addEventListener('contextmenu', (e) => {
            if (!e.target.closest('.room-list-item') && !e.target.closest('.message-wrapper')) {
                hideContextMenu();
            }
        });


        messageForm.addEventListener('submit', (e) => {
            e.preventDefault();
            sendMessage(messageInput.value);
        });

        document.getElementById('create-room-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const roomName = document.getElementById('new-room-name').value.trim();
            if (roomName) createRoom(roomName);
        });

        document.getElementById('set-name-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const displayName = displayNameInput.value.trim();
            if (displayName) setProfile(displayName);
        });
        
        // --- NEW: Add event listener for search input ---
        roomSearchInput.addEventListener('input', () => {
            renderRooms(allCachedRooms);
        });


        async function initializeApp() {
            // 1. Get/Set User Profile
            const storedName = await fetchProfile(currentUserId);
            if (storedName) {
                currentUserName = storedName;
            } else {
                await setProfile('Anonymous');
            }
            renderProfile();
            
            // 2. Immediately fetch rooms to populate the list and cache
            const initialFetchResult = await apiCall('rooms');
            if (initialFetchResult.success) {
                 allCachedRooms = initialFetchResult.data;
                 renderRooms(allCachedRooms); 
            }

            // 3. Determine Initial Room
            const urlHash = getUrlHash(); 
            const urlQueryRoomName = getUrlParam('room');
            
            let joinAction = null; 

            if (urlHash) {
                joinAction = urlHash; 
            } else if (urlQueryRoomName) {
                joinAction = { type: 'implicit_create', name: urlQueryRoomName }; 
            } else if (DEFAULT_EMBEDDED_ROOM_NAME) {
                joinAction = { type: 'default', name: DEFAULT_EMBEDDED_ROOM_NAME };
            }

            if (joinAction) {
                await handleRoomJoin(joinAction);
            } else {
                startRoomPolling();
            }
        }

        window.onload = initializeApp;
    </script>
</body>
</html>
